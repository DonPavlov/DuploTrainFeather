#include "Arduino.h"
#include "train_control.hpp"


volatile int8_t g_speed { 0 };
volatile int8_t g_lastSpeed{ 0 };

// Constants
static const unsigned long callback_execution_delay{ 50 };
static const unsigned long m_hub_delay { 20 };
bool m_initialized{ false };

unsigned long executionTimeMillis { 0 };
unsigned long prevExecutionMillis { 0 };
unsigned long currentExecutionMillis { 0 };


std::map<Commands::Commands, std::string> commandNames = {
  { Commands::Commands::Forward,
    "Forward" },
  { Commands::Commands::Backward,
    "Backward" },
  { Commands::Commands::Stop,
    "Stop" },
  { Commands::Commands::Light,
    "Light"   },
  { Commands::Commands::Refill,
    "Refill"    },
  { Commands::Commands::Horn,
    "Horn"  },
  { Commands::Commands::Steam,
    "Steam" },
  { Commands::Commands::Departure,
    "Departure" },
  { Commands::Commands::Faster,
    "Faster" },
  { Commands::Commands::Slower,
    "Slower" },
  { Commands::Commands::None,
    "None"  }
};

static void colorSensorCb(void      *hub,
                          byte       portNumber,
                          DeviceType deviceType,
                          uint8_t   *pData)
{
  Lpf2Hub *mHub = (Lpf2Hub *)hub;

  if (deviceType == DeviceType::DUPLO_TRAIN_BASE_COLOR_SENSOR)
  {
    int color = mHub->parseColor(pData);

    if (color == (byte)RED)
    {
      mHub->playSound((byte)DuploTrainBaseSound::BRAKE);
    }
    else if (color == (byte)BLUE)
    {
      mHub->playSound((byte)DuploTrainBaseSound::WATER_REFILL);
    }
    else if (color == (byte)YELLOW)
    {
      mHub->playSound((byte)DuploTrainBaseSound::HORN);
    }
  }
}

// TODO add a timeout to the traincommands after having received a successfull command
static void speedometerSensorCb(void      *hub,
                                byte       portNumber,
                                DeviceType deviceType,
                                uint8_t   *pData)
{
  Lpf2Hub *mHub  = (Lpf2Hub *)hub;
  byte     mPort = (byte)DuploTrainHubPort::MOTOR;

  if (deviceType == DeviceType::DUPLO_TRAIN_BASE_SPEEDOMETER)
  {
    int speed = mHub->parseSpeedometer(pData);

    if (speed > 10)
    {
      if (g_speed <= 0)
      {
        g_speed = 50;
      }

      if (g_lastSpeed <= 0)
      {
        Serial1.println("Forward");
        Serial1.print("Speed: ");
        Serial1.println(speed);
        mHub->setBasicMotorSpeed(mPort, g_speed); // Don't like the callbacks here.Kind of annoying
        g_lastSpeed = g_speed;
      }
    }
    else if (speed < -10)
    {
      if (g_speed >= 0)
      {
        g_speed = -50;
      }

      if (g_lastSpeed >= 0)
      {
        Serial1.println("Back");
        Serial1.print("Speed: ");
        Serial1.println(speed);
        mHub->setBasicMotorSpeed(mPort, g_speed);
        g_lastSpeed = g_speed;
      }
    }
    else
    {
      Serial1.println("Stop");
      g_speed = 0;
      mHub->stopBasicMotor(mPort);
    }
  }
}

void TrainControl::init_hub()
{
  m_hub.init();
}

void TrainControl::setup_loop()
{
  if (!checkConnectionToTrain())
  {
    Serial1.println("Train not connected");

    if (m_hub.isConnecting())
    {
      m_hub.connectHub();
      Serial1.println("Connecting...");
      delay(100);

      if (m_hub.isConnected())
      {
        Serial1.println("Connected to Duplo Hub");

        delay(200);
        delay(200);

        // connect speed sensor and activate it for updates
        m_hub.activatePortDevice((byte)DuploTrainHubPort::SPEEDOMETER,
                                 speedometerSensorCb);
        delay(200);

        // connect color sensor and activate it for updates
        m_hub.activatePortDevice((byte)DuploTrainHubPort::COLOR,
                                 colorSensorCb);
        delay(200);
        m_hub.setLedColor(GREEN);
      }
      else
      {
        Serial1.println("Failed to connect to Duplo Hub");
      }
    }
  }
}

void TrainControl::sendCommand(Commands::Commands cmd)
{
  bool result = false;
  constexpr size_t buf_size { 32 };
  char cstr[buf_size] = { 0 };

  snprintf(cstr, buf_size, "Command %d: %s", static_cast<int>(cmd), commandNames[cmd].c_str());
  Serial1.println(cstr);

  if (checkConnectionToTrain())
  {
    result = true;
    byte mPort = (byte)DuploTrainHubPort::MOTOR;

    currentExecutionMillis = millis();


    bool execute = currentExecutionMillis >= (prevExecutionMillis + executionTimeMillis);


    switch (cmd)
    {
    case Commands::Commands::Forward:
    {
      if (execute)
      {
        if (0 >= g_speed)
        {
          g_speed = 50;
        }

        m_hub.setBasicMotorSpeed(mPort, g_speed);
        prevExecutionMillis = currentExecutionMillis;
        executionTimeMillis = 50;
      }
      break;
    }

    case Commands::Commands::Backward:
    {
      if (execute)
      {
        if (0 <= g_speed)
        {
          g_speed = -50;
        }

        m_hub.setBasicMotorSpeed(mPort, g_speed);
        prevExecutionMillis = currentExecutionMillis;
        executionTimeMillis = 50;
      }

      break;
    }


    case Commands::Commands::Stop:
    {
      if (execute)
      {
        m_hub.playSound((byte)DuploTrainBaseSound::BRAKE);
        delay(m_hub_delay);
        m_hub.setBasicMotorSpeed(mPort, 0);
        prevExecutionMillis = currentExecutionMillis;
        executionTimeMillis = 50;
      }

      break;
    }

    case Commands::Commands::Light:
    {
      if (execute)
      {
        // TODO add color cycling
        static Color test = Color::PINK;

        m_hub.setLedColor(test);
        prevExecutionMillis = currentExecutionMillis;
        executionTimeMillis = 50;
      }

      break;
    }

    case Commands::Commands::Refill:
    {
      if (execute)
      {
        m_hub.playSound((byte)DuploTrainBaseSound::WATER_REFILL);
        prevExecutionMillis = currentExecutionMillis;
        executionTimeMillis = 50;
      }

      break;
    }

    case Commands::Commands::Horn:
    {
      if (execute)
      {
        m_hub.playSound((byte)DuploTrainBaseSound::HORN);
        prevExecutionMillis = currentExecutionMillis;
        executionTimeMillis = 50;
      }

      break;
    }


    case Commands::Commands::Steam:
    {
      if (execute)
      {
        m_hub.playSound((byte)DuploTrainBaseSound::STEAM);
        prevExecutionMillis = currentExecutionMillis;
        executionTimeMillis = 50;
      }

      break;
    }

    case Commands::Commands::Departure:
    {
      if (execute)
      {
        m_hub.playSound((byte)DuploTrainBaseSound::STEAM);
        prevExecutionMillis = currentExecutionMillis;
        executionTimeMillis = 50;
      }

      break;
    }

    case Commands::Commands::Faster: {
      if (execute)
      {
        increaseSpeed();

        m_hub.setBasicMotorSpeed(mPort, g_speed);
        prevExecutionMillis = currentExecutionMillis;
        executionTimeMillis = 50;
      }

      break;
    }

    case Commands::Commands::Slower:
    {
      if (execute)
      {
        decreaseSpeed();

        m_hub.setBasicMotorSpeed(mPort, g_speed);
        prevExecutionMillis = currentExecutionMillis;
        executionTimeMillis = 50;
      }

      break;
    }

    default:
      executionTimeMillis = 0;
      break;
    }

    if (!execute)
      result = false;
  }
}

void TrainControl::increaseSpeed()
{
  g_speed += 10;

  if (g_speed > 100)
  {
    g_speed = 100;
  }
  else if (g_speed < -100)
  {
    g_speed = -100;
  }
}

void TrainControl::decreaseSpeed()
{
  g_speed -= 10;

  if ((g_speed < 10) && (g_speed > -10))
  {
    g_speed = 0;
  }
}

int8_t TrainControl::getSpeed()
{
  return g_speed;
}

bool TrainControl::checkConnectionToTrain()
{
  if (m_hub.isConnected())
  {
    m_connected = true;
    Serial1.println("connected");
  }
  else
  {
    m_connected = false;
    Serial1.println("not connected");
  }
  return m_connected;
}
